# goit-algo-hw-10

# Лінійне програмування та рандомізовані алгоритми

## Опис завдання

Завдання полягає у перевірці правильності розрахунків значення інтеграла функції за допомогою методу Монте-Карло, щоб підтвердити точність методу Монте-Карло, шляхом порівняння отриманого результату та аналітичних розрахунків або результату виконання функції quad. Зробіть висновки. 

## Функція

Для цього завдання була обрана функція, графік якої являє собою коло радіусом 1:

$$x^{2} + y^{2} = 1$$, чи $$y = \sqrt{1-x^{2}}$$


## Графік функції

![graf_func](https://github.com/PavlenkoOksana/goit-algo-hw-10/assets/107678761/64086390-7c82-4f33-9ec5-06e0adb9d868)


## Результати розрахунків значення інтеграла функції за допомогою методу Монте-Карло

Для порівняння ефективності алгоритмів, були проведені тести, з різними параметрами виклику функцій (основну увагу було приділено сумі, яку потрібно видати покупцеві). Результати тестування наведені в таблицях:


| сума      | 113 | 100 | 1 056 | 1 130 053 | 11 300 537 |
| --------------    |:-----:|:-----:|:-----:|:-----:|:-----:|
| кіл-ть монет | 3 | 6 | 6 | 6 | 6 |
| жадібний |4.49997e-06|6.39999e-06|5.200039e-06|7.90000e-06|5.60000e-06|
| динамічний|5.98999e-05|7.17000e-05|0.00125|0.88265|8.81887|


Як можна побачити у результатах тестування, ефективність жадібного алгоритму не дуже відрізняється від параметрів виклику функції find_coins_greedy, в той час, як для алгоритму динамічного програмування, вочевидь, є пропорційна залежність від параметрів виклику find_min_coins.

### Жадібний алгоритм (find_coins_greedy):

Жадібний алгоритм вибирає найбільшу доступну монету на кожному кроці, намагаючись максимізувати кількість виданих монет.
Ефективний для швидкого розрахунку видачі решти.
Недолік: не завжди дає оптимальний результат.

### Алгоритм динамічного програмування (find_min_coins):

Алгоритм динамічного програмування розв'язує задачу оптимального розподілу монет для кожної суми.
Ефективний для знаходження мінімальної кількості монет для будь-якої суми.


### Для невеликих сум:

Обидва алгоритми працюють добре, і час виконання буде приблизно однаковим. В проведених тестах при сумах 100 та 113 час виконання обох алгоритмів був незначним, однак слід зазначити, що жадібний алгоритм працював приблизно у 10 разів швидше.

### Для великих сум:

Як підтвердили тести, жадібний алгоритм працює швидше через свою простоту і відсутність необхідності робити розрахунки для всіх можливих комбінацій.
Алгоритм динамічного програмування може вимагати більше обчислювальних ресурсів, оскільки розрахунки здійснюються для всіх сум від 0 до заданої суми. Наприклад розрахунку для суми 11 300 537, жадібному алгоритму потрібно 5.6000001222855644e-06 сек, в той час, як алгоритму динамічного програмування потрібно 8,82 сек. 

## Результати роботи алгоритмів

Загалом, обираючи між жадібним алгоритмом та алгоритмом динамічного програмування, слід враховувати конкретні обставини та вимоги задачі. Жадібний алгоритм може бути швидшим та працювати добре для певних сценаріїв, але алгоритм динамічного програмування гарантує оптимальність відповіді.

## Часова скаладність

Жадібний алгоритм (find_coins_greedy):

Часова складність цього алгоритму є лінійною O(n), де n - кількість різних номіналів монет.
Оскільки алгоритм просто вибирає найбільший доступний номінал, кількість операцій зазвичай лінійно залежить від кількості різних номіналів.

Алгоритм динамічного програмування (find_min_coins):

Часова складність алгоритму динамічного програмування для цієї задачі при побудові таблиці dp_table залежить від обраної суми для видачі та кількості різних номіналів монет. Часова складність дорівнює O(s * n), де s - сума, n - кількість різних номіналів монет. При побудові результату, часова складність мінша за O(s * n), тому можемо її ігнорувати.

## Висновки

Результати тестів ефективності жадібного алгоритму та алгоритму динамічного програмування показали, що жадібний алгоритм є більш ефективним за часом виконання, оскільки він не виконує складних обчислень, в той час, як алгоритм динамічного програмування гарантує оптимальність, але він вимагає більше обчислювальних ресурсів, особливо при роботі з великими діапазонами сум.

